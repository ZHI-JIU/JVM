# 堆

## 堆的核心概述
- 一个进程对应一个jvm实例，只有一个堆内存。堆是java内存管理的核心区域。
- java堆在jvm启动时即被创建，其大小有确定了（可调节的）。是jvm中最大的一块内存空间。
    - Xms 初始堆空间大小
    - Xmx 最大堆空间大小
- 堆可以物理上不连续，逻辑上是连续的。物理内存和虚拟内存有映射表，虚拟内存中连续的部分在实际的物理内存上是不连续的。
- 堆是线程共享的，但是可以在堆上划分出线程私有的**缓冲区**（Thread Local Allocation Buffer，TLAB），为了提升并发性能。
- jvm规范：所有的对象实例、数组都应当在运行时分配在堆上。实际使用时可以具体分体具体分析。也有可能存储在栈上。
- 数组和对象可能永远不会存储在栈上，因为栈帧保存引用，引用指向对象、数组在堆中的位置。
- 方法结束后，堆中的对象不会马上被移除（栈帧会出栈，堆中的对象只是没有局部变量表中的引用指向它），在GC时才会被移除。
- 堆是GC的重点区域。

### 堆的内存细分
现代的GC大部分都是基于分代收集理论设计的。
- jdk7及以前，逻辑上分为三部分：
    - 新生区
        - Eden区
        - Survivor区
          - survivor0区（from区）
          - survivor1区（to区）
    - 养老区
    - 永久区（方法区的落地方案）
- jdk8及以后，逻辑上分为三部分：
    - 新生区
        - Eden区
        - Survivor区
          - survivor0区（from区）
          - survivor1区（to区）
    - 养老区
    - 元空间（方法区的落地方案）

## 设置堆内存大小与OOM
- Xms 初始堆空间（新生代+老年代）大小，等价于-XX:InitialHeapSize
    - -X：jvm的运行参数
    - ms：member start的缩写
- Xmx 最大堆空间大小，等价于-XX:MaxHeapSize
- 默认值：
    - 初始内存： 物理内存 / 64
    - 最大内存： 物理存储 / 4
- 获取jvm中的堆内存大小
    ``Runtime.getRuntime().totalMemory()``  
- 获取jvm中的最大堆内存大小 
    ``Runtime.getRuntime().maxMemory()``
- 这两个值最好设置成一样，减少扩缩容对服务器的压力。    
- 查看堆空间的大小：
    - 方式一： jps查看进程号 + jstat -gc 进程号 查看各个区的大小和已使用空间
    - 方式二： -XX：+PrintGCDetails，程序执行完后会输出。  
    ![image](GCdetail)
    
## 年轻代与老年代
- jvm中的java对象按生命周期来看分为两类：
  - 生命周期较短的瞬时对象。这类对象的创建和消亡都非常快。
  - 生命周期长，在极端情况下可以与jvm的生命周期保持一致。
  - 因此jvm的内存可以再细分一下，把生命周期长的放在回收周期的区块可以减少损耗。
- 堆进一步细分，可以分为年轻代和老年代。
- 年轻代又可以分成eden区、s0区、s1区。

![image](heap)

### 分配比例
#### 新生代和老年代
- 默认``-XX:NewRatio=2``，新生代1，老年代2。
- 可以改为``-XX:NewRatio=4``，新生代1，老年代4。
- 一般不会调，生命周期长的对象多时可以考虑调整。

#### 新生代中三个区
- 默认eden：s0：s1是8:1:1
  - 实际看到的结果可能不是8:1:1，因为jvm有自适应机制
  - 关闭自适应的内存分配策略：``-XX:-UseAdaptiveSizePolicy``（实际不起作用）
  - 需要手动通过``-XX:SurvivorRatio=8``来设置。数值是eden区的比重，s0、s1默认是1。
- 几乎所有的java对象都是在Eden区被new出来的。除非特别大，eden区放不下，直接放到老年代。
- 绝大部分的java对象的销毁都在新生代进行。
- ``-Xmn``：设置新生代的空间大小。
- ``-Xmn``和``-XX:NewRatio``都指定时按``-Xmn``生效。

## 对象分配过程
### 一般过程
1. new出来的对象先放eden区（实体放在堆空间，变量放在jvm栈的局部变量表中）
2. eden区满了以后触发young gc/Minor GC。
3. 已经没有引用指向的回收，还有指向的放在s0区，并赋予age 1。（此时eden区清空）
4. 再次满了照样触发young gc。
5. eden区已经没有引用指向的回收，还有指向的放在s1区（谁空放哪里，空的也叫to区，to区是不确定的），并赋予age 1。
6. s0区也触发gc，还有引用的放到s1区，age递增1岁。（此时eden、s0是空的，s0变成下一轮的to区）
7. 依次触发，当s0、s1区有age到15时，放入老年区。

- survivor区的gc是在eden区满时被动触发的，它自己满时不会触发young gc。满了以后会直接进到老年区。
- 频繁收集新生代（80%会被回收），很少在老年代收集，几乎不在永久区/元空间收集。

### 特殊情况
- 要分配内存时，eden放不下，并且eden区触发gc后仍然放不下，会去判断老年区是否能放下，老年区能放就放，不能放触发老年区的full gc/major gc，之后还是放不下就OOM。
- YGC时，eden区有部分对象会需要移动到s0、s1区（已经随着YGC回收过了），如果survivor区放不下，直接放到老年代。

![image](specialGC)



## Minor GC，Major GC，Full GC

## 堆空间分代思想

## 内存分配策略

## 为对象分配内存：TLAB

## 堆空间的参数设置
- XX 
- jstat -gc 进程号 查看gc情况
- jps 查看当前进程
- -XX：+PrintGCDetails

## 堆是分配对象的唯一选择么