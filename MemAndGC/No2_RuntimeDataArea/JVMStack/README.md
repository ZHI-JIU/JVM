# 虚拟机栈

## 概述
### 为什么会有虚拟机栈
由于java是一种跨平台语言，不能基于寄存器来实现（不同平台的cpu架构不同），所以java指令都是根据栈来设计的。
- 优点：跨平台，指令集小，编译器容易实现
- 缺点：进栈出栈导致的性能下降，实现同样功能需要更多的指令。

### 栈和堆：
- 栈是运行时的单位，解决程序如何执行，如何处理数据。
- 堆是存储的单位。解决数据如何存储，该放在哪里，怎么放。

### java虚拟机栈：
- 存储的内容：一个个的栈帧。一个栈帧对应一次java方法调用

  [例]

  ![image]()
- 线程私有。
- 生命周期：和线程一致。每个线程在创建时会创建一个虚拟机栈
- 作用：主管java程序的运行，保存方法的**局部变量（8种基本类型，对象的引用地址）、部分结果**，并参与方法的**调用**和**返回**。
- 优点：
  - 快速有效的分配存储方式，访问速度仅次于PC寄存器。
  - jvm直接对java栈的操作只有两个：
    - 入栈：方法执行
    - 出栈：方法执行结束
    
  遵循”先进先出，后进后出“的原则。
- 栈不存在gc问题（只针对栈顶的元素进行操作），不同于pc寄存器的是，栈会有oom问题，栈开辟时是有一定大小的，不断入栈不出栈的话就会溢出。pc寄存器是对上一个值不断地覆盖，所以不会有oom的问题。
  
### 虚拟机栈的常见异常
jvm允许java栈的大小是**动态**的或**固定不变**的。
- OOMError：采用动态大小的java虚拟机栈，在扩容时若无法申请到内存，或者创建线程时就没有足够内存去创建栈，就会抛出该异常。
- StackOverFlowError：采用固定大小的java虚拟机栈，每个线程java虚拟机栈的容量在线程创建时确定。线程中入栈的栈帧超过容量就会抛出该异常。
  ```java
      // 演示stackOverFlow
      public static void main(String[] args) {
          main(args);
      }
  ```
  ```java
  Exception in thread "main" java.lang.StackOverflowError
      at MemAndGC.No2_RuntimeDataArea.JVMStack.StackErrorTest.main(StackErrorTest.java:6)
  
  ```

### 设置栈内存大小
- 栈大小直接决定了函数调用的**最大可达深度**。
- 通过参数``-Xss``设置线程的最大栈空间。

没有设置栈大小时：
```java
public class StackErrorTest {
    private static int count = 1;
    // 演示stackOverFlow
    public static void main(String[] args) {
        System.out.println("count: " + count);
        count++;
        main(args);
    }
}
```
```java
...
count: 6915
count: 6916Exception in thread "main" java.lang.StackOverflowError
	at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)
        ...
```

设置栈的大小

![image]()

```java
...
count: 2054
count: 2055
count: 2056
Exception in thread "main" java.lang.StackOverflowError
	at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)
	at sun.nio.cs.UTF_8.access$200(UTF_8.java:57)
        ...
```

## 栈的存储单位
### 栈中存储什么
- 存储栈帧
- 线程中每个执行的方法都对应一个栈帧
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。
- 一个活动的线程中，一个时刻只会有一个活动的栈帧，称为**当前栈帧**，与之对应的方法称为**当前方法**，定义这个方法的类就是**当前类**。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行。
- 如果在当前方法中调用了其他方法，对应的新栈帧会被创建，入栈，称为新的当前栈帧。

![image](stack)

### 栈运行原理
- 不同线程中所包含的栈帧是不允许存在相互引用的。
- 如果在当前方法中调用了其他方法，对应的新栈帧会被创建，入栈，称为新的当前栈帧，这个方法执行完后，会传回次方法的执行结果给前一个栈帧，接着栈帧出栈，使前一个栈帧重新称为当前栈帧。
- java返回函数的两种方式：
  - return正常返回
  - 抛出异常
  
  两种方式都会导致栈帧出栈

### 栈帧的内部结构
- **局部变量表**
- **操作数栈（表达式栈）**
- 动态链接：指向运行时常量池的方法引用
- 方法返回地址：方法正常退出或异常退出的定义
- 附加信息

![image](stackFrame)

## 局部变量表

- 也被称为**局部变量数组**或**本地变量表**
- 是一个数字数组（一维的）
- 数字的类型：基本数据类型、对象引用（指向堆空间中的对象）、returnAddress。
  - byte、short、char在存储前转为int。
  - boolean在存储前转为int，false为0，true为非0。
- 存储的内容：方法参数和定义在方法体内的局部变量。
- 局部变量在java栈上，线程私有，不存在数据安全问题。
- 局部变量表的容量在**编译期**确定，保存在方法的Code属性的``maximum local variables``数据项中。方法运行期间不会改变局部变量表的大小。
  ![image](maxmium)
- 方法的大小和栈的大小决定了方法的嵌套深度。方法的大小主要由局部变量表决定。方法的参数和局部变量越多，局部变量表膨胀得越厉害。
- 局部变量表中的变量只在当前方法中有效。方法执行时，jvm通过使用局部变量表完成**参数值**到**参数变量列表**的传递过程。

  方法调用结束，栈帧出栈、销毁，局部变量表也随之销毁。
- jvm性能调优中栈帧中最主要的就是局部变量表
  - 局部变量表中的变量是重要的**垃圾回收根节点**，对象引用不存在了，堆中相应指向的对象就可以被回收了，**只要被局部变量表中直接或间接引用的对象都不会被回收**。
  - 局部变量表越大，相同大小的栈中能存放的栈帧就越少。
- 方法执行时，jvm使用局部变量表来完成方法的传递。

### slot理解
- 局部变量表的基本存储单位是slot
- 存放从0开始
- 局部变量表中存放编译期可知的8种基本数据类型、引用类型、returnAddress类型的变量。
- 32位以内的类型占用一个slot，64位的（long、double）占用两个slot。
- jvm回味每个slot分配一个访问索引，通过这个索引可以访问局部变量的值。占用两个slot的通过它的起始索引来访问。
  
  ![image](indexSlot)
- 方法的参数和方法内部定义的局部变量按声明的顺序复制到局部变量表的每个slot上。
- 如果当前帧是由构造方法或者实例方法创建的，this是一个变量，会被放在index为0的slot处。其余参数按参数表顺序继续排列。（静态方法没有存放this变量，所以在静态方法中不能调用this）
  
  - static方法不允许有this：
   
    ![image](staicThis)
  - 实例方法this放在索引0上:
  
    ![image](nonStaicThis)
- 局部变量表中的slot是可以重复利用的。如果一个局部变量过了作用域，在之后声明的新的变量会复用它的槽位，达到节省资源的目的。
  ![image](slotReuse)

### 变量分类
- 按数据类型分：
  - 基本数据类型
  - 引用数据类型
- 按声明的位置：
  - 成员变量：在使用前都经历过默认初始化赋值
    - **类变量（静态变量）**
      - 在linking的prepare阶段默认赋值的。
      - 在linking的initial阶段显式赋值。
    - 实例变量
      - 对着对象的创建，会在堆空间中分配实例变量空间，并默认赋值。
  - **局部变量**：在使用前必须进行显式赋值，否则slot中没有存数据，编译不通过。

#### 静态变量和局部变量的对比
- 类变量(甚至成员变量)在使用前都经历过默认初始化赋值。
  - 在linking的prepare阶段默认赋值的。
  - 在linking的initial阶段显式赋值。

## 操作数栈
- 每一个栈帧中除了包含局部变量表外，还包含一个后进后出的操作数栈（也称表达式栈）。
- 栈可以通过数组或链表来实现，操作数栈是由数组来实现的。
- 在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据。
- 操作数栈，主要用于存储计算过程的**中间结果**。
  
  ![image](operateStackFlow)
  
- 操作数栈是jvm执行引擎的一个工作区，当方法开始执行时，栈帧被创建，此时的操作数栈是空的。
  - 操作数栈虽然是空的，但是它的数组已经创建出来了，在编译期就确定好了栈的大小。保存在方法的Code属性的``max_stack``数据项中。
- 元素内容：任意的java数据类型。
  - 32位的类型：占用1个栈深度。
  - 64位的类型：占用2个栈深度。
- 操作数栈虽然是用数组来实现的，但是不是用索引来访问的。而是要符合栈的特性，通过标准的入栈、出栈来完成访问。
- 如果调用的方法有返回值，它的返回值会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条要执行的指令。

  ![image](operateStackReturn)
- 操作数栈中元素的类型要与字节码指令的序列严格匹配。
  - 编译器在编译期会进行验证。
  - 类加载的类校验阶段的数据流分析阶段也会再次验证。
- jvm的解释引擎是基于操作数栈的执行引擎。

## 栈顶缓存技术

## 动态链接

## 方法的调用：解析与分派

## 方法返回地址

## 附加信息

## 试题