# 虚拟机栈

## 概述
### 为什么会有虚拟机栈
由于java是一种跨平台语言，不能基于寄存器来实现（不同平台的cpu架构不同），所以java指令都是根据栈来设计的。
- 优点：跨平台，指令集小，编译器容易实现
- 缺点：进栈出栈导致的性能下降，实现同样功能需要更多的指令。

### 栈和堆：
- 栈是运行时的单位，解决程序如何执行，如何处理数据。
- 堆是存储的单位。解决数据如何存储，该放在哪里，怎么放。

### java虚拟机栈：
- 存储的内容：一个个的栈帧。一个栈帧对应一次java方法调用

  [例]

  ![image]()
- 线程私有。
- 生命周期：和线程一致。每个线程在创建时会创建一个虚拟机栈
- 作用：主管java程序的运行，保存方法的**局部变量（8种基本类型，对象的引用地址）、部分结果**，并参与方法的**调用**和**返回**。
- 优点：
  - 快速有效的分配存储方式，访问速度仅次于PC寄存器。
  - jvm直接对java栈的操作只有两个：
    - 入栈：方法执行
    - 出栈：方法执行结束
    
  遵循”先进先出，后进后出“的原则。
- 栈不存在gc问题（只针对栈顶的元素进行操作），不同于pc寄存器的是，栈会有oom问题，栈开辟时是有一定大小的，不断入栈不出栈的话就会溢出。pc寄存器是对上一个值不断地覆盖，所以不会有oom的问题。
  
### 虚拟机栈的常见异常
jvm允许java栈的大小是**动态**的或**固定不变**的。
- OOMError：采用动态大小的java虚拟机栈，在扩容时若无法申请到内存，或者创建线程时就没有足够内存去创建栈，就会抛出该异常。
- StackOverFlowError：采用固定大小的java虚拟机栈，每个线程java虚拟机栈的容量在线程创建时确定。线程中入栈的栈帧超过容量就会抛出该异常。
  ```java
      // 演示stackOverFlow
      public static void main(String[] args) {
          main(args);
      }
  ```
  ```java
  Exception in thread "main" java.lang.StackOverflowError
      at MemAndGC.No2_RuntimeDataArea.JVMStack.StackErrorTest.main(StackErrorTest.java:6)
  
  ```

### 设置栈内存大小
- 栈大小直接决定了函数调用的**最大可达深度**。
- 通过参数``-Xss``设置线程的最大栈空间。

没有设置栈大小时：
```java
public class StackErrorTest {
    private static int count = 1;
    // 演示stackOverFlow
    public static void main(String[] args) {
        System.out.println("count: " + count);
        count++;
        main(args);
    }
}
```
```java
...
count: 6915
count: 6916Exception in thread "main" java.lang.StackOverflowError
	at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)
        ...
```

设置栈的大小

![image]()

```java
...
count: 2054
count: 2055
count: 2056
Exception in thread "main" java.lang.StackOverflowError
	at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)
	at sun.nio.cs.UTF_8.access$200(UTF_8.java:57)
        ...
```

## 栈的存储单位
### 栈中存储什么
- 存储栈帧
- 线程中每个执行的方法都对应一个栈帧
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。
- 一个活动的线程中，一个时刻只会有一个活动的栈帧，称为**当前栈帧**，与之对应的方法称为**当前方法**，定义这个方法的类就是**当前类**。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行。
- 如果在当前方法中调用了其他方法，对应的新栈帧会被创建，入栈，称为新的当前栈帧。

![image](stack)

### 栈运行原理
- 不同线程中所包含的栈帧是不允许存在相互引用的。
- 如果在当前方法中调用了其他方法，对应的新栈帧会被创建，入栈，称为新的当前栈帧，这个方法执行完后，会传回次方法的执行结果给前一个栈帧，接着栈帧出栈，使前一个栈帧重新称为当前栈帧。
- java返回函数的两种方式：
  - return正常返回
  - 抛出异常
  
  两种方式都会导致栈帧出栈

### 栈帧的内部结构
- **局部变量表**
- **操作数栈（表达式栈）**
- 动态链接：指向运行时常量池的方法引用
- 方法返回地址：方法正常退出或异常退出的定义
- 附加信息

下面三个统称帧数据区。

![image](stackFrame)

## 局部变量表

- 也被称为**局部变量数组**或**本地变量表**
- 是一个数字数组（一维的）
- 数字的类型：基本数据类型、对象引用（指向堆空间中的对象）、returnAddress。
  - byte、short、char在存储前转为int。
  - boolean在存储前转为int，false为0，true为非0。
- 存储的内容：方法参数和定义在方法体内的局部变量。
- 局部变量在java栈上，线程私有，不存在数据安全问题。
- 局部变量表的容量在**编译期**确定，保存在方法的Code属性的``maximum local variables``数据项中。方法运行期间不会改变局部变量表的大小。
  ![image](maxmium)
- 方法的大小和栈的大小决定了方法的嵌套深度。方法的大小主要由局部变量表决定。方法的参数和局部变量越多，局部变量表膨胀得越厉害。
- 局部变量表中的变量只在当前方法中有效。方法执行时，jvm通过使用局部变量表完成**参数值**到**参数变量列表**的传递过程。

  方法调用结束，栈帧出栈、销毁，局部变量表也随之销毁。
- jvm性能调优中栈帧中最主要的就是局部变量表
  - 局部变量表中的变量是重要的**垃圾回收根节点**，对象引用不存在了，堆中相应指向的对象就可以被回收了，**只要被局部变量表中直接或间接引用的对象都不会被回收**。
  - 局部变量表越大，相同大小的栈中能存放的栈帧就越少。
- 方法执行时，jvm使用局部变量表来完成方法的传递。

### slot理解
- 局部变量表的基本存储单位是slot
- 存放从0开始
- 局部变量表中存放编译期可知的8种基本数据类型、引用类型、returnAddress类型的变量。
- 32位以内的类型占用一个slot，64位的（long、double）占用两个slot。
- jvm回味每个slot分配一个访问索引，通过这个索引可以访问局部变量的值。占用两个slot的通过它的起始索引来访问。
  
  ![image](indexSlot)
- 方法的参数和方法内部定义的局部变量按声明的顺序复制到局部变量表的每个slot上。
- 如果当前帧是由构造方法或者实例方法创建的，this是一个变量，会被放在index为0的slot处。其余参数按参数表顺序继续排列。（静态方法没有存放this变量，所以在静态方法中不能调用this）
  
  - static方法不允许有this：
   
    ![image](staicThis)
  - 实例方法this放在索引0上:
  
    ![image](nonStaicThis)
- 局部变量表中的slot是可以重复利用的。如果一个局部变量过了作用域，在之后声明的新的变量会复用它的槽位，达到节省资源的目的。
  ![image](slotReuse)

### 变量分类
- 按数据类型分：
  - 基本数据类型
  - 引用数据类型
- 按声明的位置：
  - 成员变量：在使用前都经历过默认初始化赋值
    - **类变量（静态变量）**
      - 在linking的prepare阶段默认赋值的。
      - 在linking的initial阶段显式赋值。
    - 实例变量
      - 对着对象的创建，会在堆空间中分配实例变量空间，并默认赋值。
  - **局部变量**：在使用前必须进行显式赋值，否则slot中没有存数据，编译不通过。

#### 静态变量和局部变量的对比
- 类变量(甚至成员变量)在使用前都经历过默认初始化赋值。
  - 在linking的prepare阶段默认赋值的。
  - 在linking的initial阶段显式赋值。

## 操作数栈
- 每一个栈帧中除了包含局部变量表外，还包含一个后进后出的操作数栈（也称表达式栈）。
- 栈可以通过数组或链表来实现，操作数栈是由数组来实现的。
- 在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据。
- 操作数栈，主要用于存储计算过程的**中间结果**。
  
  ![image](operateStackFlow)
  
- 操作数栈是jvm执行引擎的一个工作区，当方法开始执行时，栈帧被创建，此时的操作数栈是空的。
  - 操作数栈虽然是空的，但是它的数组已经创建出来了，在编译期就确定好了栈的大小。保存在方法的Code属性的``max_stack``数据项中。
- 元素内容：任意的java数据类型。
  - 32位的类型：占用1个栈深度。
  - 64位的类型：占用2个栈深度。
- 操作数栈虽然是用数组来实现的，但是不是用索引来访问的。而是要符合栈的特性，通过标准的入栈、出栈来完成访问。
- 如果调用的方法有返回值，它的返回值会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条要执行的指令。

  ![image](operateStackReturn)
- 操作数栈中元素的类型要与字节码指令的序列严格匹配。
  - 编译器在编译期会进行验证。
  - 类加载的类校验阶段的数据流分析阶段也会再次验证。
- jvm的解释引擎是基于操作数栈的执行引擎。

## 栈顶缓存技术
jvm基于栈来实现，入栈出栈导致指令更多，操作数存储在内存中，频繁io影响执行速度。

为了解决这个问题，hotspot jvm提出了栈顶缓存技术，将栈顶元素缓存在物理cpu的寄存器中，降低内存IO。

## 动态链接
- 动态链接又称为指向运行时常量池的方法引用。
- 每一栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用。
- 存储这个引用的作用：为了支持当前方法的代码能够实现动态链接。
- 动态链接的对应是静态解析。
- java源文件被编译成字节码文件时，所有的变量和方法引用都作为**符号引用**保存在class文件的常量池里。描述一个方法调用另外一个方法，就是通过常量池中指向方法的符号引用来表示的。
  
  ![image](DynamicLinking)
  
  下面开始套娃
  ```mermaid
  graph LR;
  A[#7 methodref_info] --> B[#8 class_info]
  A --> C[#31 NameAndType_info]
  B --> D[#32 Utf8_info class_info]
  C --> E[#19 Utf8_info method_name]
  C --> F[#13 Utf8_info return_type]
  ```
  
  ![image](DynamicLinking2)
- class文件中的常量池在运行以后，会放到方法区中的运行时常量池中。
- 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

  <img alt="image" src="D:\Program Files (x86)\JetBrains\JVM\MemAndGC\No2_RuntimeDataArea\pic\DynamicLinking3.png"/>

### 为什么需要常量池
多个方法可能调用同一个方法或常量，如果每个栈帧中都存一份占用空间。存在线程共享的区块，只要在jvm占中存储一个地址即可。
常量池提供了一些符号和常量，便于指令识别。也可以通过使用更小的空间达到相同的效果。

### 方法的调用：解析与分派
jvm中将方法的符号引用转换为直接引用与方法的**绑定机制**相关。

绑定：一个字段、方法或者类在符号引用被替换为直接引用的过程，仅会发生一次。
- 早期绑定：方法在编译期可知，运行期保持不变。
- 晚期绑定：方法在编译期无法确定，只能在运行时根据实际类型绑定。

- 静态链接：早期绑定的转换过程。
- 动态链接：晚期绑定的转换过程。（多态，父类子类方法覆写，编译期不确定具体会调用哪个。实际运行时根据传入的对象可以确定用哪个方法。）

### 虚方法和非虚方法
- 虚方法：除了非虚方法外的方法。
- 非虚方法：方法在编译期确定，运行时不可变。
    - 静态方法（不能被重写的方法）
    - 私有方法（不能被重写的方法）
    - final方法（不能被重写的方法）
    - 实例构造器（只会重载，不会重写）
    - 显示地调用父类方法（子类中调用super.父类方法，明确调用的是哪个）

有的方法即使没有被重写，但是它具备能被重写的能力，也算是虚方法。

子类对象的多态性使用前提：
  1. 有类的继承关系
  2. 重写了父类的方法



### jvm中方法调用的常见指令
普通调用指令：
- invokestatic: 调用静态方法，解析阶段确定唯一方法版本（调用的非虚方法）
- invokespecial: 调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本（调用的非虚方法）
- invokevirtual: 调用虚方法（调用的虚方法或final方法）
- invokeinterface: 调用接口

动态调用指令（jdk7以后）：
- invokedynamic：动态解析出需要调用的方法，然后执行。（多用于lambda表达式）

### 静态语言&动态语言
- 静态语言：判断变量的类型信息，如java，变量具有类型属性。
- 动态语言：判断变量值的类型信息，如python，变量没有类型属性，赋值以后才具有了类型。

### 方法重写的本质
1. 找到操作数栈栈顶的第一个元素所执行的对象的实际类型。记作C。
2. 如果在类型C中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验。
   - 如果通过则返回这个方法的直接引用，查找结束。
   - 如果不通过，则返回IllegalAccessError。（一般这个异常编译期就能发现，如果运行时才出现说明类发生了不兼容的改变）
3. 如果找不到符合的方法，则按照继承关系从下往上一次对C的各个父类进行2中的搜索和验证。
4. 如果都没有找到，则返回AbstractMethodError。

- 虚方法表： 
  - 如果每次都按上述方法来找一遍很繁琐，为了提高性能，jvm在类的方法区建立一个虚方法表。使用索引表来代替查找。
  - 每个类都有一个虚方法表，表中存放着各个方法的实际入口。
  - 虚方法表会在类加载的链接阶段被创建并初始化，类的变量初始值准备完后，jvm把该类的方法表也初始化完毕。

## 方法返回地址
存放调用该方法的方法栈帧中的pc寄存器的值。 该方法结束时执行引擎拿到这个值，知道原来的方法该继续执行哪个指令。

方法退出的两种方式：
- 正常退出（包括处理完异常退出）：调用者（是一个方法，对应着一个栈帧）的pc寄存器中的值作为返回地址。
- 抛出异常退出：返回地址需要通过异常表来确定，栈帧中不保存。异常退出不会给调用者返回任何值。

## 附加信息
与虚拟机实现相关的附加信息，例如对程序调试提供支持的信息。

## 试题
### 栈溢出的情况
- stackOverFlow
- OOM（动态的大小扩容失败）

### 调整栈大小能保证不溢出么
- 不能，只会延缓出现的时间

### 分配的栈内存越大越好吗
线程独享，相同的内存，栈越大，支持的并发度越少

### 

### 垃圾回收是否涉及虚拟机栈
不涉及。出栈就能销毁。

### 方法中定义的局部变量是否线程安全
如果是方法内部造的，并且在方法内部消亡则是线程安全的。
如果是方法内部造的，又返回出去会被其他线程拿到，那就可能是不安全的。
如果是方法外传进来的参数，那可能是线程不安全的。